**데이터 정렬
1.정렬의 구분
1)오름차순(Ascending - 작은 것에서 큰 것 순으로 배치, 기본) 과 내림차순(Descending - 큰 것에서 작은 것 순으로 배치)

2)알고리즘에 의한 분류
- selection sort(선택정렬) : 교재에서 많이 설명, 정렬이 무엇인지 설명하고 제어문 학습하는 용도로 주로 이용, 실무에서느 거의 사용하지 않음

- bubble sort
- insertion sort
- quick sort
- shell sort
- heap sort
- radix sort 등

=>면접이나 코딩 테스트에서는 quick sort를 많이 물어봅니다.

2.selection sort(선택 정렬)

   	20 30 40 50 10 : 정렬 되지 않은 상태
=>첫번째 위치부터 마지막 바로 앞 위치까지 자신의 뒤에 있는 모든 데이터와 비교해서 더 작은 데이터를 자리 바꿈을 하는 방식으로 데이터를 정렬

1pass(0)  10  30  40  50  20   : 1,2,3,4
2pass(1)  10  20  40  50  30   : 2,3,4
3pass(2)  10  20  30  50  40   : 3,4
4pass(3)  10  20  30  40  50   : 4

int [] ar = {20 30 40 50 10};

int len = ar.length;

//선택 정렬
//기준 위치 반복문
for(int i=0; i< len-1; i=i+1){
	//비교 위치 반복문
	for(j=i+1; j<len; j=j+1){
		if(ar[i] > ar[j]){
			//swap
			int temp = ar[i];
			ar[i] = ar[j];
			ar[j] = temp;
		}
	}
}

3.Bubble Sort
=>최대 n(데이터 개수)-1 회전 동안 맨 앞에서 부터 자신의 바로 뒤에 있는 데이터와만 비교해서 정렬하는 방식
=>1회전이 끝나면 가장 큰 데이터가 맨 뒤로 이동
=>1회전 동안 데이터의 이동이 없으면 정렬이 된 것이므로 중단해도 됩니다.

		int [] ar = {20, 30, 40, 50, 10, 32};
		//버블 정렬은 최대 n(데이터 개수)-1 회전 동안
		//자신의 바로 뒤에 있는 데이터와 비교해서 정렬
		//오름차순이면 뒤의 데이터가 작을 때 swap
		//내림차순이면 뒤의 데이터가 클 때 swap
		
		//버블 정렬은 가장 큰 데이터가 맨 뒤로 이동하므로 하나의 회전이 끝나면
		//맨 마지막 데이터와는 비교할 필요가 없습니다.
		//1회전 동안 데이터의 이동이 없으면 정렬 종료
		
		int len = ar.length;
		
		//최대 n-1 회전
		for(int i=0; i<len-1; i=i+1){
			//1회전 동안의 데이터의 이동 여부를 판별하기 위한 변수
			boolean flag = false;
			//자신의 인접한 데이터와 비교하기 위한 제어문
			for(int j=0; j<len-i-1; j=j+1){
				//뒤의 데이터가 더 작으면 swap
				if(ar[j] > ar[j+1]){
					int temp = ar[j];
					ar[j] = ar[j+1];
					ar[j+1] = temp;
					//데이터 이동 여부 표시
					flag = true;
				}
			} 
			//데이터의 이동이 없으면 정렬 종료
			if(flag == false){
				break;
			}
		}
		
		//데이터 출력
		for(int temp : ar) {
			System.out.print(temp + "\t");
		}

**검색(search)
1.순차검색
=>데이터가 정렬되지 않았을 때 데이터를 앞에서부터 순서대로 검색
=>첫번째 데이터와 마지막 데이터의 검색 시간이 차이가 많이 나고 데이터가 없는 경우 전체 데이터를 확인해야만 없다는 사실을 알 수 있습니다.

2.제어검색
=>데이터가 정렬된 경우 사용하는 검색 방법
1)이분 검색(Binary Search): 데이터의 중앙값과 비교해서 작으면 왼쪽 크면 오른쪽에 가서 다시 중앙값과 비교하는 방식

2)피보나치 검색: 피보나치 수열의 값을 이용해서 검색
1,1,2,3,5,8,13...(첫번째 와 두번째는 1 세번째 부터는 앞쪽 2개 항의 합)

3)보간 검색
=>검색 위치를 계산해서 검색

(검색값 - 최소값) / (최대값 - 최소값) 을 계산한 후 데이터 개수와 곱해서 찾는 방식
데이터의 분포가 고르다면 제어검색 중에서 성능이 우수함

4)이진 트리 검색
=>데이터를 삽입할 때 정렬 하는 것처럼 작으면 왼쪽 크면 오른쪽에 배치해서 검색
=>이진 트리는 만들다 보면 정확하게 반으로 분할 되지는 않습니다.

3.블록 검색
=>블록 단위는 정렬되어 있지만 블록 안은 정렬이 안된 상태에서 검색

4.해싱
=>데이터를 배치할 때 함수를 이용해서 배치하는 방식
=>모든 데이터의 검색 속도가 일정하고 가장 빠른 검색 방법
=>해싱 함수의 선택은 운영체제가 합니다.

**객체 지향 프로그래밍(Object Oriented Programming - OOP)
1.객체 지향 특징
1)Encapsulation(캡슐화) : 관련있는 속성과 메소드를 묶는 것
클래스를 만드는 방법

2)Inheritance(상속성): 상위 클래스의 모든 것을 하위 클래스가 물려 받는 것

3)Polymorphism(다형성): 동일한 메시지에 대하여 다르게 반응하는 성질
=>동일한 코드가 호출하는 객체에 따라서 다른 메소드를 호출하는 것

2.객체 지향의 장점
=>코드의 재사용성이 뛰어남

3.객체 지향의 단점
=>함수형 프로그래밍 방식에 비해서 무겁다.

4.클래스와 인스턴스(객체 - 예전에는 Object)
=>최근에는 클래스도 오브젝트로 간주합니다.
=>클래스는 인스턴스들의 공통된 특징을 소유한 객체
=>클래스를 기반으로 해서 생성된 객체들을 인스턴스 라고 하기도 합니다.
=>클래스는 정적(한 번 만들면 수정이 안됨)이고 인스턴스는 동적(만들고 수정하고 삭제 할 수 있습니다)
=>클래스는 만들고 처음 사용할 때 메모리에 로드가 되서 프로그램이 종료될 때 까지 절대로 소멸되지 않습니다.
=>인스턴스는 만들어서 사용하다가 필요하면 언제든지 제거할 수 있습니다.

5.자바에서 클래스를 생성하는 방법
[접근지정자] + [클래스 종류] + class + 클래스이름 + [extends 상위클래스이름] + [implements 인터페이스이름]{
	클래스의 구성 요소 나열
}

6.클래스를 이용해서 인스턴스를 생성하는 기본 방법
new 생성자이름(매개변수 나열)
=>new 는 생성자를 기반으로 메모리 할당(allocation)을 하고 초기화(initialize)를 한 후 그 참조를 리턴합니다.
=>자바는 생성자 이름이 클래스 이름이어야 합니다.

7.클래스의 구성 요소
=>속성(attribute - 변수)
=>메소드(method): 클래스 안에 만들어져서 클래스 이름이나 인스턴스 이름으로 호출하는 함수를 메소드라고 합니다.
cpu가 작업을 하는 단위
=>생성자(constructor)

8.클래스나 인스턴스를 가지고 자신의 멤버 접근
클래스. 또는 인스턴스. 속성이름 또는 메소드이름(매개변수 나열) 의 형태로 접근 합니다.

**클래스 생성
1.클래스의 접근 지정자
=>생략(default, package - 디렉토리): 현재 패키지에서는 마음대로 사용할 수 있지만 다른 패키지에서는 사용을 못함
=>public: 어디에서든지 이 클래스를 사용할 수 있습니다.
=>private: 다른 클래스에서 이 클래스를 사용할 수 없도록 할 때 사용, 내부 클래스에만 적용
=>protected: 상속받은 클래스에서는 사용이 가능, 내부 클래스에만 적용 가능

2.자바에서는 클래스 별로 별도의 파일에 작성하는 것을 권장

3.클래스를 생성하고 인스턴스 만들기
1)클래스 만들기
=>src 디렉토리 위에 마우스 포인터 올리고 마우스 오른쪽을 누른 후 [New] - [class]를 선택하고 옵션을 작성
=>클래스 이름의 첫글자는 대문자로 시작하도록 권장
//main 메소드가 없는 클래스 - 실행할 수 없는 보조적인 역할을 수행하는 클래스
public class SampleClass {

}

2)실행 클래스를 만들고 위에서 만든 SampleClass의 인스턴스 만들기
public class MainClass {

	public static void main(String[] args) {
		//SampleClass 의 인스턴스 만들기
		//new SampleClass() 가 인스턴스를 만드는데 
		//위의 구문은 수행을 하고 인스턴스의 참조를 리턴합니다.
		//이 인스턴스를 재사용할려면 인스턴스의 참조를 동일한 자료형의 변수에 대입을 해야 합니다.
		SampleClass obj = new SampleClass();

	}

}

**속성 또는 변수
1.변수의 종류
=>동일한 영역에서 동일한 이름으로 변수를 2번 생성할 수 없습니다. 

1)Local Variable(지역 변수)
=>메소드 안에서 만들어져서 메소드 안에서만 사용 가능한 변수
=>메소드 안에 존재하는 다른 블록 안에서 만들어지면 그 블록 안에서만 사용이 가능합니다.
=>접근 지정자를 사용하지 않습니다.

=>생성
자료형 변수이름;
자료형 변수이름 = 값;

=>처음에 값을 대입하지 않으면 변수는 생성되지 않습니다.
지역변수는 처음 값을 대입할 때 생성됩니다.

2)Member Variable(멤버 변수)
=>클래스 내부에서 메소드 바깥에 선언된 변수로 static 이라는 키워드가 없이 만들어진 변수
=>클래스로부터 만들어지는 각 인스턴스가 자신의 특성을 표현하기 위해서 별도로 소유
=>생성할 때는 접근지정자와 함께 생성
=>변수를 만들 때 값을 대입하지 않아도 기본값으로 초기화가 됩니다.
=>false, 0, 0.0, null 등으로 초기화
접근지정자 자료형 변수명 으로 선언

3)Static Variable(클래스 변수)
=>클래스 내부에서 메소드 바깥에 선언된 변수로 static 이라는 키워드와 함께 만들어진 변수
=>동일한 클래스로부터 생성된 모든 인스턴스가 공유하기 위한 변수
=>이 변수는 1개만 생성되고 생성되면 소멸되지 않습니다.
=>생성할 때는 접근지정자와 함께 생성
=>변수를 만들 때 값을 대입하지 않아도 기본값으로 초기화가 됩니다.
=>false, 0, 0.0, null 등으로 초기화
static 접근지정자 자료형 변수명 으로 선언

2.final
=>변수 앞에 붙이면 변수의 값을 변경하지 못하도록 read only를 만들어주는 키워드

3.멤버 메소드나 멤버 변수의 접근 지정자
1)private: 클래스 내부의 메소드에서만 사용할 수 있도록 해주는 지정자
2)default(package - 생략): 동일한 패키지 내에서는 public 이고 다른 패키지에서는 private
3)protected: default에 상속받은 클래스에서도 사용할 수 있도록 해주는 지정자
4)public: 클래스 내부의 메소드에서 사용 가능하고 클래스 외부에서 인스턴스나 클래스를 이용해서 접근 가능

4.static 변수는 클래스와 인스턴스 모두 접근 가능하지만 member variable 은 인스턴스만 접근 가능
=>static 은 공통된 내용을 저장할 때 사용하고 member variable 은 각각의 특징을 저장할 때 사용

5. 실습
1)final 이 붙으면 변수의 값을 수정할 수 없습니다.
=>MainClass 의 main 메소드에 final 변수를 선언

//final 변수는 생성과 동시에 값을 할당
//값을 변경할 수 없기 때문입니다.
//final 변수의 이름은 모두 대문자로 만드것이 관례

final int TEN = 10;
//TEN = 11; //이 문장은 에러

=>final은 클래스 안에서 옵션을 만들 때 주로 이용
일반 정수 데이터를 의미있는 이름을 부여해서 이해하기 쉽게 할 목적

2)SampleClass 에 변수를 선언

//static 변수 - 클래스로 접근 가능하고 인스턴스로도 접근 가능
	//모든 인스턴스가 공유
	static int share = 1;
	
	//인스턴스 변수(멤버 변수) - 인스턴스만 접근이 가능하고 각 인스턴스가 별도로 소유
	String name;

3)MainClass 클래스의 main 메소드에서 static이 붙은 것과 그렇지 않은 변수의 차이를 알아보는 코드 작성
//SampleClass의 인스턴스를 2개 생성
		SampleClass ob1 = new SampleClass();
		SampleClass ob2 = new SampleClass();
		
		//인스턴스 변수에 값 대입
		ob1.name = "첫번째 인스턴스";
		ob2.name = "두번째 인스턴스";
		//static이 붙지 않은 멤버는 클래스는 호출할 수 없습니다.
		//SampleClass.name 은 안됨
		
		//인스턴스 변수의 값 출력 - 인스턴스 변수는 각각 소유하기 때문에 서로 다른 값 출력
		System.out.println(ob1.name);
		System.out.println(ob2.name);
		
		//static 변수에 값 대입
		//클래스와 인스턴스 모두 접근 가능
		ob1.share = 100;
		SampleClass.share = 200;
		//static 변수는 하나만 만들어서 공유
		//출력을 해보면 동일한 값을 출력
		System.out.println(ob1.share);
		System.out.println(ob1.share);
		System.out.println(SampleClass.share);

4)private 과 public 차이
=>클래스 안에서 private으로 만들어지면 클래스 안에서만 사용 가능
=>public으로 만들어지면 클래스 외부에서 클래스 이름이나 인스턴스를 통해서 사용이 가능
=>클래스 안에서 사용을 할 때는 특별한 경우가 아니라면 이름만 호출하면 됩니다.

SampleClass에서 share 변수 선언문 앞에 private을 추가하고 저장을 하면 main 메소드에 에러가 발생합니다.
이 에러는 없다라고 에러 메시지가 뜨지 않고 존재하지만 보이지 않는다는 에러 메시지가 출력

5)static 멤버를 인스턴스를 이용해서 접근하면 경고가 발생
=>static 멤버는 클래스 이름을 통해서 접근하는 것을 권장

6.static initializer
=>클래스 안에 
static{
	내용
}
=>을 작성하면 클래스가 메모리에 로드될 때 1번만 { }안의 내용을 수행
=>여기에는 static 변수는 사용할 수 있지만 member(instance) 변수는 사용할 수 없음
=>주로 static 변수의 초기화에 이용
=>여러 번 작성하면 작성 한 순서대로 실행

실습)
SampleClass에 static 초기화 블럭을 작성하고 MainClass 실행
=>가장 먼저 내용이 출력
	
//static 초기화 블럭
static {
	System.out.println("클래스가 처음 호출될 때 1번만 수행");
}

**Method
=>전달받은 데이터를 이용해서 처리를 수행한 후 결과를 돌려주는 작은 프로그램
=>Function 이라고도 하는데 보통은 Function은 아무곳에서나 호출할 수 있는 것을 의미하고 Method는 클래스나 인스턴스를 통해서만 호출할 수 있는 것을 의미합니다.

1.메소드의 생성 - 선언
[접근지정자] + [특성] + 리턴타입 + 메소드이름(매개변수자료형 매개변수이름,....) {
	메소드의 내용;
	[return 데이터;]
}

1)접근 지정자
private: 클래스 내부에서만 호출해서 사용
default(package): 패키지(디렉토리)내에서는 public 밖에서는 private
protected: default에 상속받은 클래스에서도 사용이 가능
public: 클래스 외부에서 클래스나 인스턴스를 통해서 사용 가능

2)특성
abstract(추상) - 내용이 없는 메소드
final(종단) - 재정의 할 수 없는 메소드
static - 클래스 메소드
synchronized - 동기화 메소드 : 작업 수행 도중에는 다른 스레드를 수행할 수 없도록 하는 메소드
native - C언어에서 만든 운영체제에게 직접 전달해서 실행하도록 해주는 메소드

자바 <-> JVM(Java Virtual Machine) <-> 운영체제
자바 만을 가지고 운영체제를 핸들링하는 프로그램을 만들 수 없어서 C언어로 만든 메소드를 호출해서 운영체제를 핸들링 합니다.

3)return type
=>메소드는 호출되면 자신의 작업을 수행하고 호출한 곳으로 돌아오는데 이것을 return 이라고 합니다.
=>이 때 데이터를 가지고 return 할 수 있는데 이 데이터의 자료형이 return type 입니다.
=>데이터를 가지고 오지 않는 경우에는 void 라고 기재합니다.

4)argument(매개변수)
=>함수를 호출할 때 넘겨주는 데이터
=>자바에서는 반드시 자료형과 함께 기재해야 하고 없는 경우에는 생략이 가능

2.메소드 호출
=>자신의 클래스 내부에서는 메소드이름(매개변수 나열) 의 형태로 호출 가능
=>클래스 외부에서는 클래스이름.메소드이름(매개변수 나열) 또는 클래스이름 대신에 인스턴스를 기재

3.메소드 원형
=>메소드의 내용은 생략하고 결과형 메소드이름(매개변수) 만을 의미

4.메소드 사용 이유
1)자주 사용하는 코드를 하나의 이름으로 묶어서 유지 보수를 편리하게 하기 위해서

2)프로그램을 적절한 크기로 모듈화하기 위해서
프로그램을 적절한 크기로 분할하지 않으면 읽기가 어려워지고 메모리 부족 현상이 벌어질 수 있습니다.
프로그래밍언어나 IDE 에 따라서 Stack의 크기가 정해진 경우가 있는데 이 Stack의 사이즈보다 더 큰 메모리를 사용할려고 하는 경우 Stack Overflow라는 예외가 발생합니다.

5.실습
1)Hello Java를 3번 출력하는 메소드를 소유한 클래스
public class MethodClass {
	//매개변수가 없고 리턴 타입이 void 메소드
	public void disp() {
		//메소드의 내용
		for(int i=0; i<3; i=i+1) {
			System.out.println("Hello Java");
		}
	}
}

2)main 메소드를 소유한 Main 클래스에서 위의 메소드 호출
public class Main {
	public static void main(String[] args) {
		//MethodClass 의 인스턴스를 생성
		MethodClass obj = new MethodClass();
		//메소드 호출 - 수행할 내용을 변경하고자 하면 메소드의 내용만 변경
		obj.disp();
		
		System.out.println("Hello Python");
		
		//메소드 호출
		obj.disp();
	}
}

6.Argument(매개변수)
=>메소드를 호출할 때 넘겨주는 데이터
=>메소드를 실행하는데 필요한 데이터
=>없을 수도 있고 여러 개 일 수 있습니다.
=>매개변수가 있으면 함수의 활용범위가 높아지게 됩니다.

1)MethodClass에 매개변수가 있는 메소드를 추가
// 매개변수가 정수 1개이고 리턴 타입이 void 메소드
// 이 메소드는 호출할려면 반드시 정수 1개를 넘겨주어야 합니다.

	public void print(int n) {
		// 메소드의 내용
		for (int i = 0; i < n; i = i + 1) {
			System.out.println("Hello Java");
		}
	}

2)main 메소드에서 호출
//매개변수가 있는 메소드 호출
System.out.println("========================");
obj.print(5);
System.out.println("========================");
obj.print(2);

3)메소드를 만들 때 매개변수의 개수 제한은 없지만 매개변수의 개수가 많으면 함수를 호출할 때 코드가 길어지고 매개변수의 순서대로 데이터를 대입하는 것이 어렵습니다.
이 문제를 해결하기 위해서 매개변수가 여러 개 일 때는 별도의 클래스를 만들거나 Map 을 이용하는 것을 권장합니다.

Eclipse에서는 적용이 안되지만 Intelli J 나 Android Studio에서는 매개변수 앞에 이름을 붙이는 구조를 지원을 합니다.

4)Method Overloading(메소드 중복 정의)
=>대부분의 객체 지향 언어에서는 하나의 클래스에 동일한 이름의 메소드를 여러 개 만드는 것을 지원
=>이 때 매개변수의 개수나 매개변수의 자료형은 달라야 합니다.
=>하나의 클래스에 메소드의 이름은 같고 매개변수의 개수나 자료형이 다른 경우를 메소드 오버로딩이라고 합니다.
=>동일한 알고리즘을 사용하는데 매개변수의 개수나 자료형이 다른 이유때문에 메소드 이름을 다르게 하면 메소드 이름을 기억하기도 어렵고 메소드 이름이 너무 많이 필요합니다. - C언어

=>정수 2개 덧셈하는 메소드: add(int, int)
=>실수 2개 덧셈하는 메소드: add(double, double)
=>객체 지향 언어 면접 보러 가면 반드시 기억

5)Method Overloading 구현을 위해서 MethodClass 수정
public class MethodClass {
	// 매개변수가 없고 리턴 타입이 void 메소드
	public void disp() {
		// 메소드의 내용
		for (int i = 0; i < 3; i = i + 1) {
			System.out.println("Hello Java");
		}
	}

	// 매개변수가 정수 1개이고 리턴 타입이 void 메소드
	// 이 메소드는 호출할려면 반드시 정수 1개를 넘겨주어야 합니다.
	// 동일한 이름의 메소드가 하나의 클래스에 존재하는 경우를 Method Overloading 이라고 합니다.
	public void disp(int n) {
		// 메소드의 내용
		for (int i = 0; i < n; i = i + 1) {
			System.out.println("Hello Java");
		}
	}
}

6)main 메소드에서 print 호출하는 부분을 disp로 수정

7.매개변수 전달 방법
=>value type(scala, 기본형): 변수가 데이터 자체를 의미
int a = 10;
int b = a + 5;

=>reference type(vector, 참조형): 변수가 데이터 전체의 시작 위치를 가리키는 참조
int [] ar = {100, 300, 200};
ar 은 데이터가 아니고 데이터가 저장된 곳의 참조
데이터를 찾아갈려면 ar[인덱스]를 해주어야 합니다.

1)call by value
=>매개변수의 자료형이 value 형인 경우로 메소드가 전달되는 데이터를 변경할 수 없습니다.

2)call by reference
=>매개변수의 자료형이 reference 형인 경우로 메소드가 전달되는 데이터를 변경할 수 도 있습니다.

3)실습
=>MethodClass 클래스에 2개의 메소드를 생성
하나는 정수를 받아서 1증가시키고 출력하는 메소드
다른 하나는 정수 배열을 받아서 첫번째 데이터를 1감소시키고 출력하는 메소드

	//정수 1개를 매개변수로 받아서 1증가시키고 출력하는 메소드 : Call By Value
	public void inc(int n) {
		n = n + 1;
		System.out.println("n:" + n); 
	}
	
	//배열 1개를 매개변수로 받아서 첫번째 데이터를 1감소시키고 출력하는 메소드 : Call By Reference
	public void dec(int [] ar) {
		ar[0] = ar[0] - 1;
		System.out.println("ar[0]:" + ar[0]);
	}

=>main 메소드에 확인하기 위한 코드를 작성하고 실행
int x = 100;
		int [] br = {100,200,300};
		obj.inc(x);
		//x의 값은 직접 호출해서 변경하지 않는 이상 절대로 변경되지 않음
		System.out.println("x:" + x);
		
		obj.dec(br);
		//참조형의 경우 메소드의 매개변수로 대입되면 데이터가 변경되어 있을 수도 있음
		System.out.println("br[0]:" + br[0]);

4)참조형 데이터를 받아서 작업을 하는 메소드 중에서 return을 하지 않는다면 이 메소드는 매개변수로 받은 데이터를 변경을 할 가능성이 높습니다.
단 예외적인 메소드는 화면에 무엇인가를 출력하는 메소드들입니다.
print 나 그래프 등을 그리는 메소드 등

8.varargs
=>매개변수의 개수를 지정하지 않고 대입 가능하도록 한 방식
=>java 1.5에서부터 지원
=>매개변수를 만들 때 (자료형 ... 매개변수이름) 의 형태로 작성하면 자료형의 데이터를 몇 개를 대입하던지 메소드 내에서는 매개변수이름의 배열로 취급
=>파이썬에서는 *이름 의 형태로 만들어져 있는 것과 동일
=>이 방식을 취하는 대표적인 메소드는 printf 메소드 입니다.

	//정수 데이터가 몇 개 가 오던지 합계를 구해서 출력해주는 메소드
	public void sum(int ... ar) {
		//... 이름을 이용하면 내부에서는 배열로 취급
		int sum = 0;
		//배열의 모든 데이터를 순서대로 접근해서 sum에 추가
		for(int data : ar) {
			sum = sum + data;
		}
		System.out.println("합계:" + sum);
	}

=>main 메소드에서 위의 메소드 호출
	obj.sum(10, 30);
	obj.sum(20, 30, 10, 50);

9.return
=>return은 메소드 수행 중에 메소드를 호출한 곳으로 제어권을 이동시키는 명령어
=>return을 할 때 1개의 데이터를 호출한 곳으로 가져 갈 수 있습니다.
이렇게 데이터를 가져갈 때는 메소드 이름앞에 가져갈 데이터의 자료형을 기재해야 합니다.
=>return 할 데이터가 없으면 void 라고 기재해야 합니다.
=>return 이후에 작성한 코드는 수행될 수 없기 때문에 return 이후에 실행되는 코드는 작성하면 안됩니다.
=>return 이 없는 메소드는 메소드의 결과를 가지고 다음 작업을 이어서 할 수 없지만 return이 있으면 그 결과를 가지고 다음 작업을 이어서 수행할 수 있습니다.
=>되도록이면 메소드를 만들 때 set 하는 메소드가 아니면 return을 하는 것이 좋습니다.

1)MethodClass에 리턴을 하는 메소드를 생성
	//2개의 정수를 매개변수로 받아서 더한 후 결과를 리턴하는 메소드
	//메소드 이름 앞의 자료형과 return 하는 데이터의 자료형은 일치해야 합니다.
	public int addReturn(int a, int b) {
		return (a+b);
	}

2)main 메소드에서 위의 메소드 사용
//return 이 있는 메소드
		//메소드의 수행 결과를 r에 저장
		int r = obj.addReturn(200, 300);
		System.out.println("결과:" + r);
		//이전 작업 결과를 가지고 다음 작업을 수행
		r = obj.addReturn(r, 700);
		System.out.println("결과:" + r);
		
		//return 값이 메소드는 다른 메소드의 매개변수가 될 수 있습니다.
		r = obj.addReturn(300, obj.addReturn(300, 700));
		System.out.println("결과:" + r);

10.static 메소드
=>메소드의 자료형 앞에 static을 추가한 메소드
=>static이 붙은 메소드는 클래스가 호출해도 되고 인스턴스가 호출해도 됩니다.
static이 없는 메소드는 반드시 인스턴스가 호출해야 합니다.
=>static 메소드는 인스턴스 변수 사용이 안됩니다.
=>static 변수와 자신의 메소드 안에서 만든 지역 변수만 사용이 가능
=>클래스 이름으로 호출할 때 인스턴스가 하나도 없을 수 있고 static 메소드에는 this가 없습니다.
=>이 메소드는 인스턴스 변수와 무관한 메소드를 인스턴스 생성없이 호출하기 위한 목적이나 디자인 패턴을 적용해서 인스턴스를 생성하는 용도로 만듭니다.
=>static 메소드는 특별한 경우가 아니면 클래스로 호출하는 것을 권장합니다.

11.this
=>인스턴스 메소드의 숨겨진 매개변수
=>인스턴스 메소드의 첫번째 매개변수로 우리가 생성하지 않아도 자동으로 생성됩니다.
=>인스턴스를 이용해서 메소드를 호출할 때 인스턴스의 참조가 자동으로 대입됩니다.
=>인스턴스 메소드 안에서 지역변수가 아닌 변수나 메소드를 호출할 때 앞에 자동으로 대입됩니다.
=>실제 사용은 인스턴스 메소드 안에서 지역변수와 인스턴스 변수의 이름이 같을 때 인스턴스 변수를 명시하기 위해서 사용을 합니다.





